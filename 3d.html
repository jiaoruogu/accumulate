<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç»Ÿä¸€æ¸¸æˆå¾ªç¯ - æ€§èƒ½ä¼˜åŒ–ç¤ºä¾‹</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        
        .performance-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .gamepad-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            line-height: 1.4;
            min-width: 200px;
        }
        
        .status-good { color: #00ff00; }
        .status-warning { color: #ffff00; }
        .status-bad { color: #ff0000; }
        
        .button-row {
            display: flex;
            gap: 5px;
            margin: 5px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.1s ease;
        }
        
        .btn.pressed {
            background: #00ff00;
            color: #000;
            transform: scale(1.1);
        }
        
        .controls-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 11px;
        }
        
        .optimization-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 11px;
            max-width: 250px;
        }
        
        .toggle-btn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
            pointer-events: all;
        }
        
        .toggle-btn.active {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-overlay">
        <div class="performance-panel">
            <div><strong>ğŸ¯ æ€§èƒ½ç›‘æ§</strong></div>
            <div>FPS: <span id="fps" class="status-good">60</span></div>
            <div>å¸§æ—¶é—´: <span id="frametime">16.67ms</span></div>
            <div>æ¸²æŸ“æ—¶é—´: <span id="rendertime">0ms</span></div>
            <div>è¾“å…¥æ—¶é—´: <span id="inputtime">0ms</span></div>
            <div>æ›´æ–°æ—¶é—´: <span id="updatetime">0ms</span></div>
            <div>æ€»å¾ªç¯æ•°: <span id="framecount">0</span></div>
            <div>å†…å­˜ä½¿ç”¨: <span id="memory">N/A</span></div>
        </div>
        
        <div class="gamepad-panel">
            <div><strong>ğŸ® æ‰‹æŸ„çŠ¶æ€</strong></div>
            <div id="gamepad-status">æœªè¿æ¥</div>
            <div id="gamepad-info"></div>
            <div class="button-row">
                <div class="btn" id="btn-0">A</div>
                <div class="btn" id="btn-1">B</div>
                <div class="btn" id="btn-2">X</div>
                <div class="btn" id="btn-3">Y</div>
            </div>
            <div class="button-row">
                <div class="btn" id="btn-4">LB</div>
                <div class="btn" id="btn-5">RB</div>
                <div class="btn" id="btn-8">Back</div>
                <div class="btn" id="btn-9">Start</div>
            </div>
            <div>å·¦æ‘‡æ†: <span id="left-stick">0.00, 0.00</span></div>
            <div>å³æ‘‡æ†: <span id="right-stick">0.00, 0.00</span></div>
        </div>
        
        <div class="controls-panel">
            <div><strong>âŒ¨ï¸ æ§åˆ¶è¯´æ˜</strong></div>
            <div>W/A/S/D: ç§»åŠ¨ç›¸æœº</div>
            <div>é¼ æ ‡: æ—‹è½¬è§†è§’</div>
            <div>æ‰‹æŸ„: æ§åˆ¶ç«‹æ–¹ä½“</div>
            <div>ç©ºæ ¼: æš‚åœ/ç»§ç»­</div>
        </div>
        
        <div class="optimization-panel">
            <div><strong>âš™ï¸ æ€§èƒ½ä¼˜åŒ–</strong></div>
            <button class="toggle-btn active" id="toggle-render">æ¸²æŸ“</button>
            <button class="toggle-btn active" id="toggle-input">è¾“å…¥æ£€æµ‹</button>
            <button class="toggle-btn active" id="toggle-physics">ç‰©ç†æ¨¡æ‹Ÿ</button>
            <button class="toggle-btn active" id="toggle-shadows">é˜´å½±</button>
            <div style="margin-top: 10px;">
                <div>æ¸²æŸ“è´¨é‡:</div>
                <button class="toggle-btn" onclick="setQuality('low')">ä½</button>
                <button class="toggle-btn active" onclick="setQuality('medium')">ä¸­</button>
                <button class="toggle-btn" onclick="setQuality('high')">é«˜</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== ç»Ÿä¸€æ¸¸æˆå¾ªç¯ç®¡ç†å™¨ ====================
        class UnifiedGameLoop {
            constructor() {
                this.isRunning = false;
                this.animationId = null;
                this.lastTime = 0;
                this.deltaTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                
                // æ€§èƒ½ç›‘æ§
                this.performanceMonitor = new PerformanceMonitor();
                
                // æ¨¡å—ç³»ç»Ÿ
                this.modules = new Map();
                this.moduleExecutionOrder = [];
                
                // é…ç½®
                this.config = {
                    targetFPS: 60,
                    enableVSync: true,
                    enablePerformanceMonitoring: true,
                    maxDeltaTime: 1000 / 30 // é˜²æ­¢èºæ—‹æ­»äº¡
                };
            }
            
            // æ³¨å†Œæ¨¡å—ï¼ˆæ¸²æŸ“ã€è¾“å…¥ã€ç‰©ç†ç­‰ï¼‰
            registerModule(name, module, priority = 0) {
                module.priority = priority;
                module.enabled = true;
                module.executionTime = 0;
                this.modules.set(name, module);
                
                // æŒ‰ä¼˜å…ˆçº§æ’åº
                this.moduleExecutionOrder = Array.from(this.modules.entries())
                    .sort((a, b) => a[1].priority - b[1].priority)
                    .map(entry => entry[0]);
                
                console.log(`æ¨¡å—æ³¨å†Œ: ${name} (ä¼˜å…ˆçº§: ${priority})`);
            }
            
            // å¯ç”¨/ç¦ç”¨æ¨¡å—
            toggleModule(name, enabled = null) {
                const module = this.modules.get(name);
                if (module) {
                    module.enabled = enabled !== null ? enabled : !module.enabled;
                    console.log(`æ¨¡å— ${name}: ${module.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
                }
            }
            
            // ä¸»å¾ªç¯
            start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.lastTime = performance.now();
                this.loop();
                console.log('ç»Ÿä¸€æ¸¸æˆå¾ªç¯å·²å¯åŠ¨');
            }
            
            stop() {
                if (!this.isRunning) return;
                
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                console.log('ç»Ÿä¸€æ¸¸æˆå¾ªç¯å·²åœæ­¢');
            }
            
            loop() {
                if (!this.isRunning) return;
                
                const currentTime = performance.now();
                this.deltaTime = Math.min(currentTime - this.lastTime, this.config.maxDeltaTime);
                this.lastTime = currentTime;
                this.frameCount++;
                
                // æ€§èƒ½ç›‘æ§å¼€å§‹
                const frameStartTime = performance.now();
                
                // æ‰§è¡Œæ‰€æœ‰å¯ç”¨çš„æ¨¡å—
                for (const moduleName of this.moduleExecutionOrder) {
                    const module = this.modules.get(moduleName);
                    if (module && module.enabled) {
                        const moduleStartTime = performance.now();
                        
                        try {
                            module.update(this.deltaTime, currentTime);
                        } catch (error) {
                            console.error(`æ¨¡å— ${moduleName} æ‰§è¡Œé”™è¯¯:`, error);
                        }
                        
                        module.executionTime = performance.now() - moduleStartTime;
                    }
                }
                
                // æ€§èƒ½ç›‘æ§
                if (this.config.enablePerformanceMonitoring) {
                    this.performanceMonitor.update(performance.now() - frameStartTime, this.deltaTime);
                }
                
                // è°ƒåº¦ä¸‹ä¸€å¸§
                this.animationId = requestAnimationFrame(() => this.loop());
            }
        }
        
        // ==================== æ€§èƒ½ç›‘æ§å™¨ ====================
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.frameTime = 16.67;
                this.frameHistory = [];
                this.lastUpdate = 0;
                this.updateInterval = 500; // 500msæ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
            }
            
            update(executionTime, deltaTime) {
                this.frameHistory.push({ executionTime, deltaTime, timestamp: performance.now() });
                
                // ä¿æŒæœ€è¿‘1ç§’çš„æ•°æ®
                const cutoff = performance.now() - 1000;
                this.frameHistory = this.frameHistory.filter(frame => frame.timestamp > cutoff);
                
                // æ›´æ–°æ˜¾ç¤º
                if (performance.now() - this.lastUpdate > this.updateInterval) {
                    this.updateDisplay();
                    this.lastUpdate = performance.now();
                }
            }
            
            updateDisplay() {
                if (this.frameHistory.length === 0) return;
                
                const avgDelta = this.frameHistory.reduce((sum, frame) => sum + frame.deltaTime, 0) / this.frameHistory.length;
                const avgExecution = this.frameHistory.reduce((sum, frame) => sum + frame.executionTime, 0) / this.frameHistory.length;
                
                this.fps = 1000 / avgDelta;
                this.frameTime = avgDelta;
                
                // æ›´æ–°UI
                const fpsElement = document.getElementById('fps');
                const fpsValue = Math.round(this.fps);
                fpsElement.textContent = fpsValue;
                fpsElement.className = fpsValue >= 55 ? 'status-good' : fpsValue >= 30 ? 'status-warning' : 'status-bad';
                
                document.getElementById('frametime').textContent = `${avgDelta.toFixed(2)}ms`;
                document.getElementById('framecount').textContent = gameLoop.frameCount;
                
                // æ˜¾ç¤ºå„æ¨¡å—æ‰§è¡Œæ—¶é—´
                const renderModule = gameLoop.modules.get('render');
                const inputModule = gameLoop.modules.get('input');
                const updateModule = gameLoop.modules.get('update');
                
                if (renderModule) document.getElementById('rendertime').textContent = `${renderModule.executionTime.toFixed(2)}ms`;
                if (inputModule) document.getElementById('inputtime').textContent = `${inputModule.executionTime.toFixed(2)}ms`;
                if (updateModule) document.getElementById('updatetime').textContent = `${updateModule.executionTime.toFixed(2)}ms`;
                
                // å†…å­˜ä½¿ç”¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (performance.memory) {
                    const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                    document.getElementById('memory').textContent = `${used}MB`;
                }
            }
        }
        
        // ==================== æ¸²æŸ“æ¨¡å— ====================
        class RenderModule {
            constructor(canvas) {
                this.canvas = canvas;
                this.setupThreeJS();
                this.setupScene();
                this.quality = 'medium';
            }
            
            setupThreeJS() {
                // åœºæ™¯è®¾ç½®
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // å“åº”å¼
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            setupScene() {
                // ç…§æ˜
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // åœ°é¢
                const groundGeometry = new THREE.PlaneGeometry(20, 20);
                const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                // å¯æ§åˆ¶çš„ç«‹æ–¹ä½“
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
                this.controllableCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                this.controllableCube.position.set(0, 0.5, 0);
                this.controllableCube.castShadow = true;
                this.scene.add(this.controllableCube);
                
                // æ—‹è½¬çš„ç«‹æ–¹ä½“ä»¬
                this.rotatingCubes = [];
                for (let i = 0; i < 10; i++) {
                    const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                    const material = new THREE.MeshLambertMaterial({ 
                        color: new THREE.Color().setHSL(i / 10, 1, 0.5) 
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    cube.position.set(
                        (Math.random() - 0.5) * 10,
                        Math.random() * 3 + 0.25,
                        (Math.random() - 0.5) * 10
                    );
                    cube.castShadow = true;
                    this.rotatingCubes.push(cube);
                    this.scene.add(cube);
                }
                
                // ç›¸æœºä½ç½®
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
            }
            
            update(deltaTime) {
                // æ—‹è½¬ç«‹æ–¹ä½“åŠ¨ç”»
                this.rotatingCubes.forEach((cube, index) => {
                    cube.rotation.x += deltaTime * 0.001 * (index + 1);
                    cube.rotation.y += deltaTime * 0.002 * (index + 1);
                });
                
                // æ¸²æŸ“åœºæ™¯
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            setQuality(quality) {
                this.quality = quality;
                switch(quality) {
                    case 'low':
                        this.renderer.setPixelRatio(0.5);
                        this.renderer.shadowMap.enabled = false;
                        break;
                    case 'medium':
                        this.renderer.setPixelRatio(1);
                        this.renderer.shadowMap.enabled = true;
                        break;
                    case 'high':
                        this.renderer.setPixelRatio(window.devicePixelRatio);
                        this.renderer.shadowMap.enabled = true;
                        break;
                }
            }
        }
        
        // ==================== è¾“å…¥æ¨¡å— ====================
        class InputModule {
            constructor(renderModule) {
                this.renderModule = renderModule;
                this.gamepadIndex = null;
                this.keys = {};
                this.mouse = { x: 0, y: 0, deltaX: 0, deltaY: 0 };
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                // é”®ç›˜
                window.addEventListener('keydown', (e) => this.keys[e.code] = true);
                window.addEventListener('keyup', (e) => this.keys[e.code] = false);
                
                // é¼ æ ‡
                window.addEventListener('mousemove', (e) => {
                    this.mouse.deltaX = e.movementX || 0;
                    this.mouse.deltaY = e.movementY || 0;
                });
                
                // æ‰‹æŸ„äº‹ä»¶
                window.addEventListener('gamepadconnected', (e) => {
                    this.gamepadIndex = e.gamepad.index;
                    document.getElementById('gamepad-status').textContent = `å·²è¿æ¥: ${e.gamepad.id}`;
                    console.log('æ‰‹æŸ„å·²è¿æ¥:', e.gamepad.id);
                });
                
                window.addEventListener('gamepaddisconnected', (e) => {
                    if (e.gamepad.index === this.gamepadIndex) {
                        this.gamepadIndex = null;
                        document.getElementById('gamepad-status').textContent = 'æœªè¿æ¥';
                        console.log('æ‰‹æŸ„å·²æ–­å¼€');
                    }
                });
                
                // æš‚åœ/ç»§ç»­
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        if (gameLoop.isRunning) {
                            gameLoop.stop();
                        } else {
                            gameLoop.start();
                        }
                    }
                });
            }
            
            update(deltaTime) {
                this.updateKeyboardInput(deltaTime);
                this.updateMouseInput(deltaTime);
                this.updateGamepadInput(deltaTime);
            }
            
            updateKeyboardInput(deltaTime) {
                const moveSpeed = deltaTime * 0.005;
                const camera = this.renderModule.camera;
                
                if (this.keys['KeyW']) camera.position.z -= moveSpeed;
                if (this.keys['KeyS']) camera.position.z += moveSpeed;
                if (this.keys['KeyA']) camera.position.x -= moveSpeed;
                if (this.keys['KeyD']) camera.position.x += moveSpeed;
            }
            
            updateMouseInput(deltaTime) {
                if (this.mouse.deltaX !== 0 || this.mouse.deltaY !== 0) {
                    const sensitivity = 0.002;
                    const camera = this.renderModule.camera;
                    
                    // ç®€å•çš„é¼ æ ‡è§†è§’æ§åˆ¶
                    camera.rotation.y -= this.mouse.deltaX * sensitivity;
                    camera.rotation.x -= this.mouse.deltaY * sensitivity;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    this.mouse.deltaX = 0;
                    this.mouse.deltaY = 0;
                }
            }
            
            updateGamepadInput(deltaTime) {
                if (this.gamepadIndex === null) return;
                
                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[this.gamepadIndex];
                if (!gamepad) return;
                
                // æ›´æ–°UIæ˜¾ç¤º
                this.updateGamepadUI(gamepad);
                
                // æ§åˆ¶ç«‹æ–¹ä½“ç§»åŠ¨
                const moveSpeed = deltaTime * 0.003;
                const cube = this.renderModule.controllableCube;
                
                // å·¦æ‘‡æ†æ§åˆ¶XZç§»åŠ¨
                if (gamepad.axes.length >= 2) {
                    const leftX = gamepad.axes[0];
                    const leftY = gamepad.axes[1];
                    
                    if (Math.abs(leftX) > 0.1) cube.position.x += leftX * moveSpeed;
                    if (Math.abs(leftY) > 0.1) cube.position.z += leftY * moveSpeed;
                }
                
                // å³æ‘‡æ†æ§åˆ¶Yç§»åŠ¨å’Œæ—‹è½¬
                if (gamepad.axes.length >= 4) {
                    const rightX = gamepad.axes[2];
                    const rightY = gamepad.axes[3];
                    
                    if (Math.abs(rightY) > 0.1) cube.position.y += -rightY * moveSpeed;
                    if (Math.abs(rightX) > 0.1) cube.rotation.y += rightX * moveSpeed;
                }
                
                // æŒ‰é”®æ§åˆ¶é¢œè‰²
                if (gamepad.buttons[0].pressed) { // Aé”®
                    cube.material.color.setHex(0xff0000);
                } else if (gamepad.buttons[1].pressed) { // Bé”®
                    cube.material.color.setHex(0x0000ff);
                } else if (gamepad.buttons[2].pressed) { // Xé”®
                    cube.material.color.setHex(0xffff00);
                } else if (gamepad.buttons[3].pressed) { // Yé”®
                    cube.material.color.setHex(0xff00ff);
                } else {
                    cube.material.color.setHex(0x00ff00);
                }
            }
            
            updateGamepadUI(gamepad) {
                // æ›´æ–°æŒ‰é”®æ˜¾ç¤º
                gamepad.buttons.forEach((button, index) => {
                    const btnElement = document.getElementById(`btn-${index}`);
                    if (btnElement) {
                        if (button.pressed) {
                            btnElement.classList.add('pressed');
                        } else {
                            btnElement.classList.remove('pressed');
                        }
                    }
                });
                
                // æ›´æ–°æ‘‡æ†æ˜¾ç¤º
                if (gamepad.axes.length >= 4) {
                    document.getElementById('left-stick').textContent = 
                        `${gamepad.axes[0].toFixed(2)}, ${gamepad.axes[1].toFixed(2)}`;
                    document.getElementById('right-stick').textContent = 
                        `${gamepad.axes[2].toFixed(2)}, ${gamepad.axes[3].toFixed(2)}`;
                }
            }
        }
        
        // ==================== æ›´æ–°æ¨¡å— ====================
        class UpdateModule {
            constructor() {
                this.time = 0;
            }
            
            update(deltaTime) {
                this.time += deltaTime;
                // è¿™é‡Œå¯ä»¥æ·»åŠ æ¸¸æˆé€»è¾‘æ›´æ–°
                // æ¯”å¦‚ç‰©ç†æ¨¡æ‹Ÿã€AIã€ç¢°æ’æ£€æµ‹ç­‰
            }
        }
        
        // ==================== åˆå§‹åŒ–å’Œå¯åŠ¨ ====================
        const canvas = document.getElementById('canvas');
        const gameLoop = new UnifiedGameLoop();
        
        // åˆ›å»ºæ¨¡å—
        const renderModule = new RenderModule(canvas);
        const inputModule = new InputModule(renderModule);
        const updateModule = new UpdateModule();
        
        // æ³¨å†Œæ¨¡å—ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼šè¾“å…¥ -> æ›´æ–° -> æ¸²æŸ“ï¼‰
        gameLoop.registerModule('input', inputModule, 1);
        gameLoop.registerModule('update', updateModule, 2);
        gameLoop.registerModule('render', renderModule, 3);
        
        // UIæ§åˆ¶
        document.getElementById('toggle-render').addEventListener('click', function() {
            gameLoop.toggleModule('render');
            this.classList.toggle('active');
        });
        
        document.getElementById('toggle-input').addEventListener('click', function() {
            gameLoop.toggleModule('input');
            this.classList.toggle('active');
        });
        
        document.getElementById('toggle-physics').addEventListener('click', function() {
            gameLoop.toggleModule('update');
            this.classList.toggle('active');
        });
        
        window.setQuality = function(quality) {
            renderModule.setQuality(quality);
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.optimization-panel .toggle-btn').forEach(btn => {
                if (btn.textContent === 'ä½' || btn.textContent === 'ä¸­' || btn.textContent === 'é«˜') {
                    btn.classList.remove('active');
                }
            });
            event.target.classList.add('active');
        };
        
        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        gameLoop.start();
        
        console.log('ç»Ÿä¸€æ¸¸æˆå¾ªç¯ç³»ç»Ÿå·²åˆå§‹åŒ–');
        console.log('æ¨¡å—:', Array.from(gameLoop.modules.keys()));
    </script>
</body>
</html>